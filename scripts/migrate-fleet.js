#!/usr/bin/env node

/**
 * üîÑ MIGRACI√ìN DE FLEET.JS
 * Script para migrar de Fleet.js original a Fleet.refactored.js
 * Incluye backup autom√°tico y validaci√≥n de migraci√≥n
 */

const fs = require('fs');
const path = require('path');

class FleetMigrator {
    constructor() {
        this.projectRoot = path.resolve(__dirname, '..');
        this.originalFile = path.join(this.projectRoot, 'src/entities/Fleet.js');
        this.refactoredFile = path.join(this.projectRoot, 'src/entities/Fleet.refactored.js');
        this.backupFile = path.join(this.projectRoot, 'src/entities/Fleet.original.js');
    }

    /**
     * Ejecutar migraci√≥n completa
     */
    async migrate() {
        console.log('üöÄ INICIANDO MIGRACI√ìN DE FLEET.JS');
        console.log('=====================================');

        try {
            // 1. Validar archivos
            this.validateFiles();

            // 2. Crear backup
            this.createBackup();

            // 3. Reemplazar archivo
            this.replaceFile();

            // 4. Validar migraci√≥n
            this.validateMigration();

            console.log('‚úÖ MIGRACI√ìN COMPLETADA EXITOSAMENTE');
            console.log('=====================================');
            console.log('üìÅ Backup creado en: Fleet.original.js');
            console.log('üîÑ Fleet.js ahora usa la versi√≥n refactorizada');
            console.log('üß™ Ejecuta las pruebas para validar funcionalidad');

        } catch (error) {
            console.error('‚ùå ERROR EN LA MIGRACI√ìN:', error.message);
            this.rollback();
            process.exit(1);
        }
    }

    /**
     * Validar que los archivos existen
     */
    validateFiles() {
        console.log('üîç Validando archivos...');

        if (!fs.existsSync(this.originalFile)) {
            throw new Error(`Archivo original no encontrado: ${this.originalFile}`);
        }

        if (!fs.existsSync(this.refactoredFile)) {
            throw new Error(`Archivo refactorizado no encontrado: ${this.refactoredFile}`);
        }

        console.log('‚úÖ Archivos validados');
    }

    /**
     * Crear backup del archivo original
     */
    createBackup() {
        console.log('üíæ Creando backup...');

        try {
            fs.copyFileSync(this.originalFile, this.backupFile);
            console.log('‚úÖ Backup creado exitosamente');
        } catch (error) {
            throw new Error(`Error creando backup: ${error.message}`);
        }
    }

    /**
     * Reemplazar archivo original con versi√≥n refactorizada
     */
    replaceFile() {
        console.log('üîÑ Reemplazando archivo...');

        try {
            fs.copyFileSync(this.refactoredFile, this.originalFile);
            console.log('‚úÖ Archivo reemplazado exitosamente');
        } catch (error) {
            throw new Error(`Error reemplazando archivo: ${error.message}`);
        }
    }

    /**
     * Validar que la migraci√≥n fue exitosa
     */
    validateMigration() {
        console.log('üß™ Validando migraci√≥n...');

        try {
            // Verificar que el archivo existe y tiene contenido
            const stats = fs.statSync(this.originalFile);
            if (stats.size === 0) {
                throw new Error('El archivo migrado est√° vac√≠o');
            }

            // Verificar que contiene la clase Fleet refactorizada
            const content = fs.readFileSync(this.originalFile, 'utf8');
            if (!content.includes('FLEET REFACTORED')) {
                throw new Error('El archivo no contiene la versi√≥n refactorizada');
            }

            if (!content.includes('FormationFactory')) {
                throw new Error('El archivo no contiene las dependencias refactorizadas');
            }

            console.log('‚úÖ Migraci√≥n validada');
        } catch (error) {
            throw new Error(`Error validando migraci√≥n: ${error.message}`);
        }
    }

    /**
     * Rollback en caso de error
     */
    rollback() {
        console.log('üîô Ejecutando rollback...');

        try {
            if (fs.existsSync(this.backupFile)) {
                fs.copyFileSync(this.backupFile, this.originalFile);
                console.log('‚úÖ Rollback completado');
            }
        } catch (error) {
            console.error('‚ùå Error en rollback:', error.message);
        }
    }

    /**
     * Mostrar informaci√≥n de la migraci√≥n
     */
    showInfo() {
        console.log('üìä INFORMACI√ìN DE LA MIGRACI√ìN');
        console.log('===============================');

        try {
            const originalStats = fs.statSync(this.backupFile);
            const refactoredStats = fs.statSync(this.originalFile);

            console.log(`üìÅ Archivo original: ${(originalStats.size / 1024).toFixed(2)} KB`);
            console.log(`üìÅ Archivo refactorizado: ${(refactoredStats.size / 1024).toFixed(2)} KB`);
            
            const reduction = ((originalStats.size - refactoredStats.size) / originalStats.size) * 100;
            if (reduction > 0) {
                console.log(`üìâ Reducci√≥n de tama√±o: ${reduction.toFixed(1)}%`);
            } else {
                console.log(`üìà Incremento de tama√±o: ${Math.abs(reduction).toFixed(1)}%`);
            }

        } catch (error) {
            console.log('‚ÑπÔ∏è  No se pudo calcular estad√≠sticas de archivos');
        }
    }
}

// Ejecutar migraci√≥n si se llama directamente
if (require.main === module) {
    const migrator = new FleetMigrator();
    
    migrator.migrate().then(() => {
        migrator.showInfo();
    }).catch((error) => {
        console.error('‚ùå Migraci√≥n fallida:', error.message);
        process.exit(1);
    });
}

module.exports = FleetMigrator; 